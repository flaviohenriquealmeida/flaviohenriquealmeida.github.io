---
layout: post
title:  "Entendendo Redux com vanilla JavaScript"
description: xxx.
date: 2018-02-26 08:00:00 -0300
categories:
permalink: /entendendo-redux-com-vanilla-javascript/
author: flavio_almeida
tags: [javascript, redux, SSOT]
image: logo.png
---
Há um número considerável de soluções no mercado para construção de Single Page Applications. Todavia, independente da solução escolhida, lidar com o gerenciamento de estado (state) da aplicação é sempre um desafio. Um padrão para gerenciamento de estados que se popularizou na comunidade foi o <a href="https://redux.js.org/" target="_blank">**Redux**</a>, inclusive sendo integrado em frameworks populares do mercado: 

* <a href="https://github.com/ngrx/store" target="_blank">nxStore</a>, Angular
* <a href="https://github.com/reactjs/react-redux" target="_blank">react-redux</a>, React
* <a href="https://vuex.vuejs.org/en/intro.html" target="_blank">vuex</a>, Vuejs
* <a href="http://www.ember-redux.com/" target="_blank">ember-redux</a>, Emberjs

Neste artigo aplicaremos o padrão promovido pelo Redux com vanilla JavaScript. Essa abordagem minimalista nos ajudará a focar nos principais conceitos de Redux independente de framework ou biblioteca para construção de Single Page Applications. 

Antes de construirmos nosso pequeno projeto, veremos brevemente os principais princípios preconizados pelo Redux.

## Sobre Redux

O próprio site do <a href="https://redux.js.org/" target="_blank">**Redux**</a> o define como um container de estado previsível. Ele se baseia em três princípios:

* SSOT (Single Source of Truth): o estado (state) de toda a aplicação é armazenado em uma árvore de objetos dentro de uma única **store**. Ela é a única fonte de verdade sobre o estado da aplicação.
* O estado é somente leitura: a única maneira de mudar o estado é emitindo uma **action**, um objeto que descreve o que aconteceu.
* Mudanças são realizadas através de funções puras: essas funções puras são chamadas **reducers**. A partir de **actions** os reducers especificam como a árvore de estado deve ser transformada.

>*Uma função pura (*pure function*) é aquela que ao receber os mesmos argumentos retornará sempre o mesmo valor. Esse termo faz parte do jargão da programação funcional, inclusive funções desse tipo são fáceis de testar.*

Não nos aprofundaremos nas definições, pois elas emergirão ao longo do nosso pequeno projeto. O autor entende que para compreender Redux é necessário conciliar teoria e prática. 

Nossa prática consistirá na criação de um pequeno projeto que demandará configurações mínimas.

## Preparando um pequeno projeto

Para que possamos ver a arquitetura Redux em ação criaremos unm pequeno projeto que utilizará o básico do Webpack para que possamos carregar módulos baixados através do `npm`, o gerenciador de módulos do Node.js.

Primeiro, vamos criar a pasta `project` e dentro dela o arquivo `index.html`:

```html
<!-- project/index.html -->
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Redux with vanilla JavaScript</title>
</head>
<body>
    <input class="userName" placeholder="user name">
    <p class="status"></p>
    <script src="dist/bundle.js"></script>
</body>
</html>
```

É uma página simples que possui apenas um `<input>` para que o usuário informe seu nome e um `<p>` que exibirá em tempo real o nome informado pelo usuário. Por fim, a tag `<script>` carregará  o `bundle.js` gerado através do Webpack. Esse *bundle*, além do nosso código, conterá a biblioteca padrão do Redux que utilizaremos.

Agora, dentro da pasta `project/app` vamos criar o módulo `app.js` com o script necessário para que o `<p>` seja atualizado a cada dígito do usuário em `<input>`:

```javascript
// app/app.js
const statusParagraph = document.querySelector('.status');

document
.querySelector('.userName')
.oninput = e => {
    const userName = e.target.value;
    statusParagraph.textContent = userName 
        ? `${e.target.value} is typing` 
        : '';
};
```

Agora que já temos a estrutura mínima do projeto, vamos instalar e configurar rapidamente o Webpack para que possamos ver a aplicação em ação:

## Instalando o Webpack e o Webpack Dev Server

No terminal e dentro da pasta `project`, vamos criar o arquivo `package.json` através do comando:

```bash
npm init -y
```

Com o `package.json` criado, vamos baixar os módulos do Webpack e do Webpack Dev Server de uma só vez:

```bash
npm install webpack@3.11.0 webpack-dev-server@2.11.1 -D
```

Por fim, vamos criar o arquivo `project/webpack.config.js` com a configuração mínima que gerará o `bundle.js`:

```javascript
// project/webpack.config.js
const path = require('path');

module.exports = {
    entry: './app/app.js',
    output: {
        filename: 'bundle.js',
        path: path.resolve(__dirname, 'dist'),
        publicPath: 'dist'
    }
}; 
```

Para terminar a configuração, adicionaremos em `project/package.json` o script `"start"` responsável pela execução do `webpack-dev-server` que carregará as configurações definidas em `webpack.config.js`:

```javascript
{
  "name": "project",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "start": "webpack-dev-server"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "webpack": "^3.11.0",
    "webpack-dev-server": "^2.11.1"
  }
}
```

Ainda dentro da pasta `project`, vamos iniciar nosso servidor através do comando:

```bash
npm start
```

Acessamos nossa aplicação através do endereço `http://localhost:8080`. Depois de carregada, experimente digitar no único `<input>` da página. Instantaneamente o valor digitado será exibido no `<p>` logo abaixo do `<input>`. 

Agora que já temos um pequeno projeto chegou a hora de modificá-lo para que faça uso do `Redux`.

## Instalando o módulo redux

Com o servidor parado, ainda na pasta `project` vamos instalar o módulo `redux`:

```bash
npm install redux@3.7.2 -S
```

Lembre-se que ao utilizarmos Redux, teremos uma **única store** que armazenará o estado de toda a aplicação. Não poderia ser diferente, já que ela será nossa única fonte de verdade sobre seu estado. Vamos criar nossa `store` no módulo `app/store.js`:

```javascript
app/store.js
// vazio, por enquanto
```

Por enquanto nosso módulo não terá qualquer código, porque seu estado inicial será definido através do único **reducer** que nossa simples aplicação terá. **Uma aplicação pode ter um ou mais `reducers` que no final são combinados para criar a única `store` da aplicação**. 

## O papel dos reducers

Lembre-se que o **reducer é o responsável em especificar como o estado (state) da aplicação armazenado na *store* deve ser transformado**. Essa decisão se baseia nas `actions` recebidas:

```javascript
// app/reducers/statusReducer.js
const initialState = { status: '' };

export const statusReducer = (state = initialState, action) => {
    // ainda falta implementar
};
```
A variável `initialState` é um objeto que representa o estado incial da aplicação. Esse objeto pode ter uma ou mais propriedades, em nosso caso, ele possui apenas uma propriedade que define o estado de `status`. Seu valor inicial é uma string em branco. 


Em seguida, definimos nossa função pura, isto é, nosso `reducer` que recebe **sempre** como parâmetro o **estado** da aplicação e a **action** disparada. Através de *default parameter* indicamos que o valor padrão do parâmetro `state` será `initialState`, aquele objeto que define o estado inicial da aplicação.


```javascript
// app/reducers/statusReducer.js
const initialState = { status: '' };

export const statusReducer = (state = initialState, action) => {
    // Nova mensagem de status para ser atualizada 
    // no estado da aplicação, isto é, na store
    const status = action.payload;
};
```

Ainda não vimos como criar *actions* em nossa aplicação, mas o mais importante é entender que uma action é um objeto que possui as propriedades **type** e **payload**. O primeiro é o tipo de ação, aliás, um *reducer*  pode estar preparado para lidar com diversos tipos de ação. Já o segundo é o valor associado a esse tipo, geralmente o valor que desejamos atualizar na *store*. Não esqueça que nosso *reducer* mais tarde será utilizado para construir nossa *store*, pois isso ele recebe sempre como parâmetro o `state`, isto é, o estado da *store*. 

Em breve criaremos uma *action* cujo o **type** será a string `'CHANGE_STATUS'`. Ela será despachada toda vez que quisermos atualizar o estado `status` da nossa *store*.  É por isso que o valor de `action.payload` será a nova mensagem de status que desejamos que desejamos atualizar na *store*.

>Por enquanto é bom ter em mente que despachamos actions com auxílio da store, na maioria das vezes, a partir das ações do usuário.

Como um *reducer* potencialmente pode lidar com uma ou mais *actions*, faremos um `switch` que decidirá qual lógica executar com base no tipo da *action* recebida:

```javascript
// app/reducers/statusReducer.js
const initialState = { status: '' };

export const statusReducer = (state = initialState, action) => {
    
    const status = action.payload;

    switch (action.type) {
        case 'CHANGE_STATUS':
            // modificar o estado aqui
        default:
            return state;
    }
};
```
É importante que nosso *reducer* retorne o estado atual da aplicação caso a *action* disparada não tenha sido definida, por isso adicionamos a cláusula `default` em nosso `switch`. 

Excelente, todavia chegamos a uma das partes mais importantes do `Redux`. O estado da aplicação deve ser imutável, isto é, não deve mudar. Para quem esta começando com Redux essa questão da imutabilidade pode dar um nó na cabeça. Quando dizemos imutável, significa que para modificarmos o estado da aplicação precisaremos criar um novo object `state` com base no `state` anterior.

Nesse sentido, uma abordagem imprópria na hora de atualizar o estado da aplicação é a seguinte:

```javascript
// app/reducers/statusReducer.js
const initialState = { status: '' };

export const statusReducer = (state = initialState, action) => {
    
    const status = action.payload;

    switch (action.type) {
        case 'CHANGE_STATUS':
            // NÃO FAÇAM ISSO!
            state.status = status;
        default:
            return state;
    }
};
```
No código anterior, ocorreu a mutação do `state` da aplicação. Isto é, aproveitamos o mesmo o objeto (referência) e modificamos sua propriedade `status`. Uma abordagem imutável é a seguinte:

```javascript
// app/reducers/statusReducer.js
const initialState = { status: '' };

export const statusReducer = (state = initialState, action) => {
    
    const status = action.payload;

    switch (action.type) {
        case 'CHANGE_STATUS':
            return Object.assign({}, state, { status });
        default:
            return state;
    }
};
```
>Se temos um artefato imutável, como realizamos alterações? Criamos um novo artefato e copiamos os valores do artefato atual, inclusive definindo novos valores para as propriedades que desejamos que sejam diferentes no artefato final.

A função `Object.assign()` é usada para copiar os valores de todas as propriedades próprias enumeráveis de um ou mais objetos de origem para um objeto destino. Este método irá retornar o objeto destino. 


Em nosso caso, o primeiro parâmetro `{}` é o objeto destino, isto é, um novo objeto sem qualquer propriedade. Já os demais parâmetros são os objetos que terão suas propriedades copiadas para o objeto destino.

Quando passamos mais de um objeto cuja as propriedades serão copiadas para `Object.assign()`, se determinada propriedade existir em mais de um objeto, será o valor da propriedade do último objeto passado como parâmetro que fará parte do objeto destino. É por isso que passamos `{ status }` como último parâmetro.

>A partir do ES2018 podemos usar o Spread Operator com propriedades de objeto. Isso nos permitirá substituir o verboso `Object.assign({}, state, { status })` por `{ ...state, status }`. 

Agora que já temos nosso *reducer* implementado, construiremos nosso *store* que o utilizará durante sua criação.

Vamos alterar o módulo `app/store.js` importando a função `createStore` do módulo `redux` e nosso `statusReducer`. 

```javascript
// app/store.js
import { createStore } from 'redux';
import { statusReducer } from './reducers/statusReducer';

export const store = createStore(statusReducer);
```

A função `createStore` recebeu como parâmetro o `statusReducer` para poder criar a nossa `store`. É a `store` criada que será exportada pelo módulo. Lembre-se, em Redux podemos ter vários *reducers* responsáveis em lidar com ações e atualizar determinados o estado da aplicação, mas os estados ficam centralizados em um único lugar, a *store*.

>Se tivéssemos mais de um reducer precisaríamos combiná-los para então passar o resultado da combinação para a função `createStore`. Esse processo de combinar *reducers* é feito através da função `combineStores`, também definida no módulo `redux`.

Agora que já temos nossa `store` pronta, vamos partir para a implementação da única *action* da aplicação. 

## O papel das actions

Uma *action* na arquitetura Redux nada mais é do que um objeto com as propriedades `type` e `payload`. Já falamos sobre essas propriedades durante a implementação de `statusReducer`. 

*Actions* são despachadas através da função `dispatch` da nossa `store`. Vejamos um exemplo isolado, que não entra em nossa aplicação:

```javascript
// EXEMPLO apenas, não entra em nossa aplicação
// importa a store da aplicação
import { store } from './store.js';
// solicita a store o depacho da action
store.dispatch({
    type: 'CHANGE_STATUS',
    payload: 'Calopsita is typing'
})
```
No código anterior, nosso *reducer* responderá à ação `CHANGE_STATUS` recebendo o valor do `payload`. É com base nesse valor a *store* será atualizada. Um ponto a destacar é que efeitos colaterais (side effects) são realizados em ações e não em nossos *reducers*. Exemplos de *side effects* são chamadas a console.log() e requisições ajax. 

Todavia, essa abordagem que adotamos deixa um pouco a desejar. Se uma ação deste tipo é usada em diversos lugares da aplicação e de uma hora para outra precisarmos mudar seu tipo, teremos que alterar em diversos lugares. Uma solução para o problema é definirmos  **action creators**.

## Flexibilidade com Action Creators

*Action creators* são funções que ao serem invocadas retornam uma **action**. Vamos criar o módulo `app/actions/status.js` e dentro dele definir um *action creator* para a ação 'CHANGE_STATUS':

```javascript
// app/actions/status.js
export const changeStatus = userName => {
    return {
        type: 'CHANGE_STATUS',
        payload: `${userName} is typing`
    }
};
```
O módulo `app/actions/status.js` exporta apenas um *action creator* que declaramos na função `changeStatus`. Essa função recebe como parâmetro um `userName` que ao ser chamada retorna uma *action*. Podemos simplificar ainda mais o código desta maneira:

```javascript
// app/actions/status.js
export const changeStatus = userName => ({
    type: 'CHANGE_STATUS',
    payload: `${userName} is typing`
});
```

Agora, voltando ao exemplo isolado exibido anteriormente e fazendo uso do nosso *action creator*:

```javascript
// EXEMPLO apenas, não entra em nossa aplicação
import { store } from './store.js';
// importou o action creator
import { changeStatus } from './actions/status.js';

store.dispatch(changeStatus('Calopsita is typing'));
```
Excelente, escondemos os detalhes da *action* `'CHANGE_STATUS'`. Todavia, nosso código pode ficar ainda melhor.

## Criando constantes

Se analisarmos os módulos `app/reducers/statusReducer.js` e `app/actions/status.js` veremos que cada um deles define a string `CHANGE_STATUS`. Além de termos o nome duplicado, nada impede o programador de acidentalmente escrever o tipo da action errado. 

Para solucionar o problema que acabamos de ver, vamos declarar os tipos das actions como constantes em um módulo sem separado chamado `app/constants/actionTypes.js` e usar esse módulo em todos os lugares que os tipos forem necessários:

```javascript
// app/constants/actionTypes.js
export const CHANGE_STATUS = 'CHANGE_STATUS';
```

Utilizando a constante em `app/actions/status.js`:

```javascript
// app/actions/status.js
// importa as constantes
import * as types from '../constants/actionTypes.js';

export const changeStatus = userName => ({
    // utiliza a constante
    type: types.CHANGE_STATUS,
    payload: `${userName} is typing`
});
```

E também no módulo `app/reducers/statusReducer.js`:

```javascript
// app/reducers/statusReducer.js
// importa as constantes
import * as types from '../constants/actionTypes';

const initialState = { status: '' };

export const statusReducer = (state = initialState, action) => {
    
    const status = action.payload;

    switch (action.type) {
        // utiliza a constante
        case types.CHANGE_STATUS:
            return Object.assign({}, state, { status });
        default:
            return state;
    }
};
```
Nosso código ficou mais organizado e menos sujeito a erro.

Temos nossa *store* (criada a partir de `statusReducer`) e nosso *action creator* `changeStatus` utilizando constantes em comuns definidas em `actionTypes`. Chegou a hora de realizamos mudanças no estado da aplicação despachando ações através das ações do usuário.

## Despachando actions

Vamos importar nossa `store` e o *action creator*  `changeStatus` no módulo `app/app.js`. Despachamos atualizações no estado da aplicação através da função `store.dispatch()`. Ela recebe a *action* retornada pelo *action creator* `changestatus`. Lembre-se que isso chegará na cláusula `switch` de `statusReducer`, o *reducer* que foi utilizado para criar nossa `store`:

```javascript
// app/app.js
import { store } from './store';
import { changeStatus } from './actions/status';

const statusParagraph = document.querySelector('.status');
document
.querySelector('.userName')
.oninput = e => {
    const userName = e.target.value;
    store.dispatch(changeStatus(userName));
};
```

Excelente, mas como sabemos que o estado da aplicação mudou? Precisamos dessa informação para que possamos atualizar nossa página. Fazemos isso através da função `store.subscribe()`. Ela será chamada toda vez que a nossa *store* mudar: 

```javascript
// app/app.js
import { store } from './store';
import { changeStatus } from './actions/status';

const statusParagraph = document.querySelector('.status');
document
.querySelector('.userName')
.oninput = e => {
    const userName = e.target.value;
    store.dispatch(changeStatus(userName));
};

store.subscribe(() => {
    // obtemos o estado atual, depois da modificação
    const state = store.getState();
    // atualizamos o elemento com o novo valor
    statusParagraph.textContent = state.status;
});
```

>Em uma aplicação com `React`, os componentes são conectados à `store` através da função `connect` do módulo `react-redux`, aquele que realiza uma ponte entre o Redux e o React, dispensando o uso de `store.subscribe`.

## Trabalhando com middlewares

Nosso código é funcional, inclusive podemos testar no navegador,  mas para transcendermos nosso entendimento sobre o que esta acontecendo podemos ativar o middleware <a href="https://github.com/evgenyrodionov/redux-logger" target="_blank">redux-logger</a>. O `redux-logger` nos permitirá visualizar as *actions* que chegam aos reducers, inclusive o estado da aplicação antes e depois de modificado. 

Ainda sobre middleware, seu conceito é o mesmo de uma aplicação criada com <a href="http://expressjs.com/" target="_blank">Express.js</a>. Nele, adicionamos um ou mais middlewares em sua pilha de middlewares e cada um deles lidará com a requisição passando o controle para o próximo middleware da pilha.

No caso do Redux, seus middlewares permitem adicionar um código específico entre o despacho da ação e o momento que ela chega ao *reducer*. 

Dentro da pasta `project`, vamos instalar o middleware:

```bash
npm install redux-logger@3.0.6 -S
```

Agora, em `app/store.js` vamos importar a função `applyMiddeware` do módulo `redux`. Essa função recebe uma quantidade indeterminada de middlewares que desejamos adicionar em uma pilha. Em seguida, vamos importar `createLogger` do módulo `redux-logger` para então ativá-lo em nosso *store*:

```javascript
import { createStore, applyMiddleware } from 'redux';
import { statusReducer } from './reducers/statusReducer';
import { createLogger  } from 'redux-logger';

const middlewares = applyMiddleware(createLogger());
export const store = createStore(statusReducer, middlewares);
```

O segundo parâmetro de `createStore` é a pilha de middlewares que desejamos aplicar. Em nosso caso, teremos um niddleware apenas, o `createLogger`.

Agora, no navegador, com o aba do console aberta, poderemos verificar que a cada dígito no `<input>` será exibida informações valiosas sobre o que esta ocorrendo com o estado da aplicação.

## Lidando com o operações assíncronas

Vimos que podemos realizar *side effects* em nossas *actions* e nunca dentro dos nossos *reducers*. Todavia, como faremos para lidar com operações assíncronas, por exemplo, requisições ajax? Nesse caso, nossos *actions creator* precisarão ser declarados de uma maneira especial.

Vamos simular uma operação assíncrona através de um `setTimeout` facilitando assim nosso teste sem dependermos de uma API para tal tarefa. 

Nosso módulo `app/actions/status.js` ficará assim:

```javascript
import * as types from '../constants/actionTypes.js';

export const changeStatus = text => 
    dispatch =>
        setTimeout(() => 
            dispatch({
                type: types.CHANGE_STATUS,
                payload: text
            })
        , 1000);
```
Nosso *action creator* não retornará mais um objeto, ele retornará uma função que ao ser chamada nos dará acesso ao `dispatch`. Sendo assim, como estamos retornando uma função, podemos executar dentro dela uma operação assíncrona. Quando ela terminar, despachamos a ação. No entanto, para que o código acima funcione, precisamos de um middleware especial. No caso, utilizaremos o `redux-thunk`. 

Vamos instalá-lo através do terminal, ainda dentro da pasta `project`:

```bash
npm install redux-thunk@2.2.0 -S
```

Como todo middleware, ele precisa ser registrado em nossa *store*:

```javascript
// project/store.js
import { createStore, applyMiddleware } from 'redux';
import { statusReducer } from './reducers/statusReducer';
import { createLogger  } from 'redux-logger';
// importou o novo middleware
import thunk from 'redux-thunk';
// adicionou o middleware thunk
const middlewares = applyMiddleware(thunk, createLogger());
export const store = createStore(statusReducer, middlewares);
```

Pronto. Basta recarregarmos nossa aplicação para verificarmos que tudo continua funcionando. Ao digitarmos no `<input>`, depois de um intervalo de tempo o *username* digitado será exibido no `<p>` como antes.

## Conclusão

O conceito do Redux é simples, o que pode complicar seu entendimento é a quantidade de artefatos envolvidos durante sua implementação e a relação entre eles. Cada framework SPA do mercado fornece módulos de terceiros ou não para realizar a ponte entre o Redux e o framework em si. E você? Já utiliza Redux sem suas aplicações? Ele trouxe benefícios? Deixe sua opinião.